Question URL: https://exploit.education/nebula/level-18/

Source Code:
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <getopt.h>

struct {
  FILE *debugfile; // File descriptor
  int verbose;
  int loggedin;
} globals;

// Variadic macro - A macro used to accept a varying number of arguments
// __VA_ARGS__: Variable number of arguments. During macro expansion each
// occurrence of the special identifier __VA_ARGS__ in the macro replacement
// list is replaced by the passed arguments
// Example
// #define DEBUG(...) printString(__VA_ARGS__)
// DEBUG("foo", "bar", "baz") is replaced with printString("foo", "bar", "baz")

#define dprintf(...) if(globals.debugfile) \
  fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile && globals.verbose >= num) \
  fprintf(globals.debugfile, __VA_ARGS__)

#define PWFILE "/home/flag18/password"

// Take a password file as an Input and compare the password from the password
// file and a given password. If exact match is found( return 0), set
// globals.loggedin value to 1
void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, "r");
  if(fp) {
      char file[64];

      if(fgets(file, sizeof(file) - 1, fp) == NULL) {
          dprintf("Unable to read password file %s\n", PWFILE);
          return;
      }
                fclose(fp);
      if(strcmp(pw, file) != 0) return;
  }
  dprintf("logged in successfully (with%s password file)\n",
      fp == NULL ? "out" : "");

  globals.loggedin = 1;

}

// If notsupported() is called, display error message and if globals.debugfile
// is defined, write "what" argument into the debugfile.
void notsupported(char *what)
{
  char *buffer = NULL;
  asprintf(&buffer, "--> [%s] is unsupported at this current time.\n", what);
  dprintf(what);
  free(buffer);
}

// If setuser(char *user) is called, display an error message and print the
// message to stdout
void setuser(char *user)
{
  char msg[128];

  sprintf(msg, "unable to set user to '%s' -- not supported.\n", user);
  printf("%s\n", msg);

}

// Takes options -d debugfile_name and/or -v
int main(int argc, char **argv, char **envp)
{
  char c;

  // Do while loop until all options are taken care.
  // d option: Save file descriptor to globals.debugfile. If file open fails
  //           print "Unable to open filename"
  //           If file open successes, immediately write(_IONBF) stream content
  //           to globals.debugfile
  // v option: Increase globals.verbose value by one. 'v' option can be more
  //           than one, like '-vvv' for increased verbosity
  while((c = getopt(argc, argv, "d:v")) != -1) {
      switch(c) {
          case 'd':
              globals.debugfile = fopen(optarg, "w+");
              if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
              // int setvbuf(FILE *stream, char *buffer, int mode, size_t size)
              // Used to control or how a stream should be buffered.
              // If buffer is set to null, the function automatically allocates
              // a buffer of the specified size.
              // mode: Determine when to write streaming content
              //      _IOFBF: Full buffering. Content is written when buffer is
              //              full
              //      _IOLBF: Line buffering. When a newline is inserted
              //      _IONBF: No buffering. Immediately write
              setvbuf(globals.debugfile, NULL, _IONBF, 0);
              break;
          case 'v':
              globals.verbose++;
              break;
      }
  }

  dprintf("Starting up. Verbose level = %d\n", globals.verbose);

  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());

  while(1) {
      char line[256];
      char *p, *q;

      q = fgets(line, sizeof(line)-1, stdin);
      if(q == NULL) break;
      // strchr(const char *s, int c) - Locate character in string
      // If a match is found(linefeend and newline), replace newline and
      // linefeed with 0 - Make inputs to one line
      p = strchr(line, '\n'); if(p) *p = 0;
      p = strchr(line, '\r'); if(p) *p = 0;

      // If globals.debugfile is defined and globals.verbose is greater than
      // 2 like -vv or -vvv, write the input(line) into global.debugfile
      dvprintf(2, "got [%s] as input\n", line);

      if(strncmp(line, "login", 5) == 0) {
          dvprintf(3, "attempting to login\n");
          // Input format: login password
          login(line + 6);
      } else if(strncmp(line, "logout", 6) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "shell", 5) == 0) {
          dvprintf(3, "attempting to start shell\n");
          if(globals.loggedin) {
              execve("/bin/sh", argv, envp);
              err(1, "unable to execve");
          }
          dprintf("Permission denied\n");
      } else if(strncmp(line, "logout", 4) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "closelog", 8) == 0) {
          if(globals.debugfile) fclose(globals.debugfile);
          globals.debugfile = NULL;
      } else if(strncmp(line, "site exec", 9) == 0) {
          // Input format: site exec Hello
          notsupported(line + 10);
      } else if(strncmp(line, "setuser", 7) == 0) {
          // Input format: setuser username
          setuser(line + 8);
      }
  }

  return 0;
}

What is ASLR?
Address space layout randomization (ASLR) is a memory-protection process for operating systems (OSes) that guards 
against buffer-overflow attacks by randomizing the location where system executables are loaded into memory.

--------------------------------------------------------------------------------------------------------------
** checksec.sh (https://github.com/RobinDavid/checksec/blob/master/checksec.sh) **
 - checksec.sh is a bash scrip to check executable properties like (PIE, RELRO, PaX, Canaries, ASLR).

level18@nebula:~$ ./checksec.sh --file /home/flag18/flag18
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   /home/flag18/flag18

level18@nebula:~$ ./checksec.sh --fortify-file /home/flag18/flag18
* FORTIFY_SOURCE support available (libc)    : Yes
* Binary compiled with FORTIFY_SOURCE support: Yes

 ------ EXECUTABLE-FILE ------- . -------- LIBC --------
 FORTIFY-able library functions | Checked function names
 -------------------------------------------------------
 fprintf_chk                    | __fprintf_chk
 fprintf_chk                    | __fprintf_chk
 fgets                          | __fgets_chk
 fgets                          | __fgets_chk
 sprintf_chk                    | __sprintf_chk
 sprintf_chk                    | __sprintf_chk
 asprintf                       | __asprintf_chk
 asprintf                       | __asprintf_chk

SUMMARY:

* Number of checked functions in libc                : 75
* Total number of library functions in the executable: 92
* Number of FORTIFY-able functions in the executable : 8
* Number of checked functions in the executable      : 4
* Number of unchecked functions in the executable    : 4
--------------------------------------------------------------------------------------------------------------

** Stack Top and Bottom **
High Address |            |
             |____________| Stack BOTTOM
             |  params    |
             |____________|
             |  rtn addr  |   |
             |____________|   | Stack grows downward
             | saved ebp  |   v
   %esp ---> |____________| Stack TOP
             |            |
Low Address  |            |

** rtn addr: Next instruction address within caller function
** saved ebp: Base address of caller. %ebp points to the start of current stack frame. When the current stack frame is done, saved ebp
   is saved to %ebp.
** %esp(Stack Pointer): Always points to the top of the current stack frame
** %ebp(Frame Pointer or Base pointer): points to the start of the stack frame and does not move 
                                        for the duration of the subroutine call.  

** The format function internally maintains a pointer to the stack location of the current format parameter. format string, %08x, 
will increase format function's internal stack pointer toward the top of the stack, lower address. Therefore each %08x format string 
keeps moving toward Stack TOP (Lower address) and some point it will overwrite Return address, saved ebp and so on.

Ref: 
Buffer Overflow 101: https://www.coengoedegebure.com/buffer-overflow-attacks-explained/
tseo: https://www.win.tue.nl/~aeb/linux/hh/formats-teso.html
Format string 101: https://www.hackerschool.org/HS_Boards/data/Lib_system/The_Mystery_of_Format_String_Exploitation.pdf
Format string exploitation: https://crypto.stanford.edu/cs155old/cs155-spring08/papers/formatstring-1.2.pdf

Print format string options: https://en.wikipedia.org/wiki/Printf_format_string
General format string: http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf
Phrack: http://phrack.org/issues/67/9.html

