Question URL: https://exploit.education/nebula/level-18/

Source Code:
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <getopt.h>

struct {
  FILE *debugfile; // File descriptor
  int verbose;
  int loggedin;
} globals;

// Variadic macro - A macro used to accept a varying number of arguments
// __VA_ARGS__: Variable number of arguments. During macro expansion each
// occurrence of the special identifier __VA_ARGS__ in the macro replacement
// list is replaced by the passed arguments
// Example
// #define DEBUG(...) printString(__VA_ARGS__)
// DEBUG("foo", "bar", "baz") is replaced with printString("foo", "bar", "baz")

#define dprintf(...) if(globals.debugfile) \
  fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile && globals.verbose >= num) \
  fprintf(globals.debugfile, __VA_ARGS__)

#define PWFILE "/home/flag18/password"

// Take a password file as an Input and compare the password from the password
// file and a given password. If exact match is found( return 0), set
// globals.loggedin value to 1
void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, "r");
  if(fp) {
      char file[64];

      if(fgets(file, sizeof(file) - 1, fp) == NULL) {
          dprintf("Unable to read password file %s\n", PWFILE);
          return;
      }
                fclose(fp);
      if(strcmp(pw, file) != 0) return;
  }
  dprintf("logged in successfully (with%s password file)\n",
      fp == NULL ? "out" : "");

  globals.loggedin = 1;

}

// If notsupported() is called, display error message and if globals.debugfile
// is defined, write "what" argument into the debugfile.
void notsupported(char *what)
{
  char *buffer = NULL;
  asprintf(&buffer, "--> [%s] is unsupported at this current time.\n", what);
  dprintf(what);
  free(buffer);
}

// If setuser(char *user) is called, display an error message and print the
// message to stdout
void setuser(char *user)
{
  char msg[128];

  sprintf(msg, "unable to set user to '%s' -- not supported.\n", user);
  printf("%s\n", msg);

}

// Takes options -d debugfile_name and/or -v
int main(int argc, char **argv, char **envp)
{
  char c;

  // Do while loop until all options are taken care.
  // d option: Save file descriptor to globals.debugfile. If file open fails
  //           print "Unable to open filename"
  //           If file open successes, immediately write(_IONBF) stream content
  //           to globals.debugfile
  // v option: Increase globals.verbose value by one. 'v' option can be more
  //           than one, like '-vvv' for increased verbosity
  while((c = getopt(argc, argv, "d:v")) != -1) {
      switch(c) {
          case 'd':
              globals.debugfile = fopen(optarg, "w+");
              if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
              // int setvbuf(FILE *stream, char *buffer, int mode, size_t size)
              // Used to control or how a stream should be buffered.
              // If buffer is set to null, the function automatically allocates
              // a buffer of the specified size.
              // mode: Determine when to write streaming content
              //      _IOFBF: Full buffering. Content is written when buffer is
              //              full
              //      _IOLBF: Line buffering. When a newline is inserted
              //      _IONBF: No buffering. Immediately write
              setvbuf(globals.debugfile, NULL, _IONBF, 0);
              break;
          case 'v':
              globals.verbose++;
              break;
      }
  }

  dprintf("Starting up. Verbose level = %d\n", globals.verbose);

  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());

  while(1) {
      char line[256];
      char *p, *q;

      q = fgets(line, sizeof(line)-1, stdin);
      if(q == NULL) break;
      // strchr(const char *s, int c) - Locate character in string
      // If a match is found(linefeend and newline), replace newline and
      // linefeed with 0 - Make inputs to one line
      p = strchr(line, '\n'); if(p) *p = 0;
      p = strchr(line, '\r'); if(p) *p = 0;

      // If globals.debugfile is defined and globals.verbose is greater than
      // 2 like -vv or -vvv, write the input(line) into global.debugfile
      dvprintf(2, "got [%s] as input\n", line);

      if(strncmp(line, "login", 5) == 0) {
          dvprintf(3, "attempting to login\n");
          // Input format: login password
          login(line + 6);
      } else if(strncmp(line, "logout", 6) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "shell", 5) == 0) {
          dvprintf(3, "attempting to start shell\n");
          if(globals.loggedin) {
              execve("/bin/sh", argv, envp);
              err(1, "unable to execve");
          }
          dprintf("Permission denied\n");
      } else if(strncmp(line, "logout", 4) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "closelog", 8) == 0) {
          if(globals.debugfile) fclose(globals.debugfile);
          globals.debugfile = NULL;
      } else if(strncmp(line, "site exec", 9) == 0) {
          // Input format: site exec Hello
          notsupported(line + 10);
      } else if(strncmp(line, "setuser", 7) == 0) {
          // Input format: setuser username
          setuser(line + 8);
      }
  }

  return 0;
}

What is ASLR?
- Address space layout randomization (ASLR) is a memory-protection process for operating systems (OSes) that guards 
against buffer-overflow attacks by randomizing the location where system executables are loaded into memory.
- With ASLR, stack,heap, and library addresses keep changing per execution.
 : Run  "$ cat /proc/self/maps" command multiple times, you can see 
- To fully utilize ASLR, you must complile your code with Position Independent Executable"-pie -fPIE"

* How to disable ASLR?
  : If ASLR is enabled, the value of /proc/sys/kernel/randomize_va_space is 2. 0 means disabling ASLR. To disable ASLR,
   use the following commands.
    $sudo -s
    # echo 0 | tee /proc/sys/kernel/randomize_va_space
** Data Execution Protection(DEP) and ASLR are the two pilars of modern exploit mitigation technologies.
** DEP remvoes executable capability from Heap and Stack. (No segment of memory should ever be Writable and
Executable at the same time) **
** DEP bypassing - Use Return Oriented Programming (ROP) ROP is a technique in exploitation to reuse existing code
gadgets in a target binary as a method to bypass DEP **
** What is Gadget in DEP?
  - A sequence of meaningful instructions typically followed by a return instruction
  - Usually multiple gadgets are chained together to compute malicious actions like shellcode does
  - These chains are called ROP Chains


What is FORTIFY_SOURCE? (Ref: https://stackoverflow.com/tags/fortify-source/info)
FORTIFY_SOURCE is a GCC and GLIBC security feature that attempts to detect certain classes of buffer overflows. 
Its enabled by default on most Linux platforms. When using the FORTIFY_SOURCE option, the compiler will insert 
code to call "safer" variants of unsafe functions if the compiler can deduce the destination buffer size. 
The unsafe functions include memcpy, mempcpy, memmove, memset, stpcpy, strcpy, strncpy, strcat, strncat, sprintf, 
snprintf, vsprintf, vsnprintf, and gets.
The option can be turned off with -D_FORTIFY_SOURCE=0 or -U_FORTIFY_SOURCE. However, its usually not appropriate 
to disable FORTIFY_SOURCE in production software.

Jakub Jelinek provided the GCC patch for FORTIFY_SOURCE back in 2004. The documentation for _FORTIFY_SOURCE is 
located in the "feature test macro" man page.

FORTIFY_SOURCE provides two countermeasures against fmt strings.
  1)   Format strings containing the %n specifier may not be located at a
       writeable address in the memory space of the application.

  2)   When using positional parameters, all arguments within the range 
       must be consumed. So to use %7$x, you must also use 1,2,3,4,5 and 6.

--------------------------------------------------------------------------------------------------------------
** checksec.sh (https://github.com/RobinDavid/checksec/blob/master/checksec.sh) **
 - checksec.sh is a bash scrip to check executable properties like (PIE, RELRO, PaX, Canaries, ASLR).

level18@nebula:~$ ./checksec.sh --file /home/flag18/flag18
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   /home/flag18/flag18

level18@nebula:~$ ./checksec.sh --fortify-file /home/flag18/flag18
* FORTIFY_SOURCE support available (libc)    : Yes
* Binary compiled with FORTIFY_SOURCE support: Yes

 ------ EXECUTABLE-FILE ------- . -------- LIBC --------
 FORTIFY-able library functions | Checked function names
 -------------------------------------------------------
 fprintf_chk                    | __fprintf_chk
 fprintf_chk                    | __fprintf_chk
 fgets                          | __fgets_chk
 fgets                          | __fgets_chk
 sprintf_chk                    | __sprintf_chk
 sprintf_chk                    | __sprintf_chk
 asprintf                       | __asprintf_chk
 asprintf                       | __asprintf_chk

SUMMARY:

* Number of checked functions in libc                : 75
* Total number of library functions in the executable: 92
* Number of FORTIFY-able functions in the executable : 8
* Number of checked functions in the executable      : 4
* Number of unchecked functions in the executable    : 4
--------------------------------------------------------------------------------------------------------------

** Stack Top and Bottom **
High Address |            |
             |____________| Stack TOP
             |  params    |
             |____________|
             |  rtn addr  |   |
             |____________|   | Stack grows downward
             | saved ebp  |   v
   %esp ---> |____________| Stack BOTTOM
             |            |
Low Address  |            |

** rtn addr: Next instruction address within caller function
** saved ebp: Base address of caller. %ebp points to the start of current stack frame. When the current stack frame is done, saved ebp
   is saved to %ebp.
** %esp(Stack Pointer): Always points to the top of the current stack frame
** %ebp(Frame Pointer or Base pointer): points to the start of the stack frame and does not move 
                                        for the duration of the subroutine call.  

******* Printf and Printf's internal stack pointer *******
** Normal printf parameters, format string, and its stack structure **
char buf[20] = "%d:%d:%d";
printf(buf, 1, 2, 3) **

High Address |            | Stack TOP
             |____________| 
   0xabcdefff| "%d:%d:%d" | <-- buf
             |____________|              
     ^       |  ....      |
     |       |  3         | <-- Last value to print
     |       |  2         | <-- second value to print
  printf     |  1         | <-- First value to print            
stack pointer|____________|
             | 0xabcdefff | <-- Pointer to format string
             |____________| 
             | rtn address| <-- Return address for printf
             |------------|
             | saved ebp  |              
   %esp ---> |____________| Stack BOTTOM
             |            |
Low Address  |            |

- Printf stack structure
   : String format is saved somewhere caller's stack area
   : From last value to print to the first value to print, paramters are saved
   : Address of string format is saved under parameters
   : Printf's internal stack pointer is moving toward Stack TOP according to reading string format one by one.

** Printf format string and its stack structure with vulnerable call **
buff="\xe0\x85\x04\x08%x%x%x%s"; <-- "\xe0\x85\x04\x08" is saved as address like 0x080485e0.
printf(buff);

High Address |            | Stack TOP
             |____________| 
             | "%x%x%x%s" | <-- buff
             | 0x080485e0 |
0xabcdefff   |____________|              
             | tmp vals by|
     ^       | gcc        |
     |       |  .....     |
stack pointer|____________|
     |       | 0xabcdefff | <-- Pointer to format string (address of buff)
             |____________| 
             | rtn address| <-- Return address for printf
             |------------|
             | saved ebp  |              
   %esp ---> |____________| Stack BOTTOM
             |            |
Low Address  |            |

- Printf workflow
 : As string format is read, tmp vals generated by gcc will be read and printed.
 : If we place a proper number of %x and %s at the end, eventually we can reach 0x080485e0 with %s format string. The result of
  this is to read and print all content until null is met from the given memory address.
 : The challenge is to figure out how many %x we need to reach the target destination
   In the above example, if we use %n instead of %s, we can write a desired value into the target address. in our example, 0xabcdefff.
   As a trick, to avoid long format string for big value to write, width specification can be used.e.g. %10000x

- How to write a specific lenght of dummy bytes to reach the destination?
%1$*479$ %1$*2848$ %1073741824$

- How Printf works with internal stack pointer? https://oded.blog/2017/05/24/printf/
- We can not move the stack pointer byte-wise, instead we move the format string itself, so that it lies on a four-byte boundary 
to the stack pointer and we can reach it with a multiple of four-byte pops

====================================================================================================
Solution from https://www.voidsecurity.in/2012/09/exploit-exercise-format-string.html
- Out of my knowledge.. just try to understand how it works. 
- Three protections used in the code
  1. FORTIFY_SOURCE protection - This solution follows A Eulogy for Format Strings of Phrack to bypass this protection
  2. Address Space Layout Randomization (ASLR)- This solution disable ASLR only for debugging purpose and enable it when a working exploit 
     is ready. No effect to exploit
  3. libc randomization - Libc randomization can be disabled using resource limit in case needed. No effect to exploit




Ref: 
Buffer Overflow 101: https://www.coengoedegebure.com/buffer-overflow-attacks-explained/
tseo: https://www.win.tue.nl/~aeb/linux/hh/formats-teso.html
Format string 101: https://www.hackerschool.org/HS_Boards/data/Lib_system/The_Mystery_of_Format_String_Exploitation.pdf
Format string exploitation: https://crypto.stanford.edu/cs155old/cs155-spring08/papers/formatstring-1.2.pdf
Nebula Level18 Information Leak solution: https://www.voidsecurity.in/2012/09/defeating-aslr-using-information-leak.html
Nebula Level18 - FORTYFY_SOURCE bypass solution: https://www.voidsecurity.in/2012/09/exploit-exercise-format-string.html

Print format string options: https://en.wikipedia.org/wiki/Printf_format_string
General format string: http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf
Phrack: http://phrack.org/issues/67/9.html

Security Lecture: http://security.cs.rpi.edu/courses/binexp-spring2015/

